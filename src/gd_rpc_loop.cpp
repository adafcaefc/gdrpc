#include "pch.h"
#include "gd_rpc_loop.h"
#include "gd_rpc_wrapper.h"
#include "gd_rpc_api.h"

namespace rpc
{
    static std::string get_text_from_key(std::string key) 
    {
        key.at(0) = std::toupper(key.at(0));
        int index = 1;
        std::for_each(key.begin() + 1, key.end(), [&index, &key](char& letter) 
            { 
                if (key.at(index - 1) == ' ')
                {
                    letter = std::toupper(letter); // then capitalizes
                }
                else if (letter == '_')
                {
                    letter = ' ';
                }
                index++; 
            });
        return key;
    }

    static std::string format_with_level(
        const std::string& s, 
        gd_level& level,
        ::gd::GJGameLevel* in_memory) 
    {
        std::string f;
        try 
        {
            f = fmt::format(
                s, fmt::arg("id", level.level_id), fmt::arg("name", level.name),
                fmt::arg("best", in_memory->normalPercent),
                fmt::arg("diff", get_text_from_key(gd_client::get_difficulty_name(level))),
                fmt::arg("author", level.author), fmt::arg("stars", level.stars),
                fmt::arg("objects", in_memory->objectCount));
        }
        catch (const fmt::format_error& e) 
        {
            f = s;
        }
        return f;
    }

    void loop::update_presence_w(
        std::string& details,
        std::string& largeText,
        std::string& smallText,
        std::string& state,
        std::string& smallImage)
    {
        if (this->update_timestamp)
        {
            std::time(&this->current_timestamp);
            this->update_timestamp = false;
        }
        discord::get()->update(
            details.c_str(),
            largeText.c_str(), 
            smallText.c_str(),
            state.c_str(), 
            smallImage.c_str(), 
            this->current_timestamp);
    }

    void loop::disable_discord() 
    {
        if (!this->enabled) return;
        this->enabled = false;
        discord::get()->shutdown();
    }

    void loop::enable_discord() 
    {
        if (this->enabled) return;
        this->enabled = true;
        discord::get()->init(this->config._settings.application_id.c_str());
    }

    void loop::close()
    {
        discord::get()->shutdown();
    }

    DWORD WINAPI loop::main_thread(LPVOID lpParam) 
    {
        while (!tm_settings::get()->gd_rpc_enable.active) 
        {
            std::this_thread::sleep_for(std::chrono::milliseconds(250));
        }
        //setupDone = true;
        loop::get()->initialize_loop();
        while (true) 
        {
            try 
            {
                loop::get()->on_loop();
            }
            catch (const std::exception& e)
            {
                // exception
            }
            catch (...) 
            {
                // unknown exception
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        }
        return TRUE;
    }

    void loop::initialize_config() 
    {
        try
        {
            const auto path = get_app_data_path() / "Local" / "ToastedMarshmellow";
            if (!std::filesystem::exists(path)) std::filesystem::create_directories(path);
            const auto filename = path / "gdrpc.toml";
            if (!std::ifstream(filename)) 
            {
                // create generic file
                std::ofstream config_file(filename);
                config_file 
                    << "# autogenerated config\n"
                    << this->config.into_toml() 
                    << std::endl;
            }

            const toml::value config = toml::parse(filename.string());
            this->config.from_toml(config);

        }
        catch (const std::exception& e) 
        {
            // Error found while trying to load config:
        }
    }

    void loop::initialize_loop()
    {
        gd_user user;
        large_text = this->config._user._default;
        const auto account_id = ::gd::GJAccountManager::sharedState()->m_nPlayerAccountID;
        
        if (this->config._user.get_rank) 
        {
            gd_client client(
                this->config._settings.base_url,
                this->config._settings.url_prefix);
            try 
            {
                bool userInfoSuccess = client.get_user_info(account_id, user);
                if (userInfoSuccess) client.get_user_rank(user);
            }
            catch (const std::exception& e) 
            {

            }
        }

        if (user.rank != -1) 
        {
            this->large_text = fmt::format(this->config._user.ranked, fmt::arg("name", user.name), fmt::arg("rank", user.rank));
        }
        else 
        {
            auto username = ::gd::GJAccountManager::sharedState()->getUsername();
            large_text = std::string(username);
        }

        update_presence = true;
        update_timestamp = true;
    }

    void loop::on_loop_level()
    {
        std::string details, s_state, small_text, small_image;
        parse_game_level(this->game_level, this->level);
        auto level_location = this->game_level->levelType;

        auto folder = static_cast<size_t>(this->game_level->levelFolder);
        if (folder >= this->config._level.size()) folder = 0;

        if (level_location == gd::GJLevelType::kGJLevelTypeEditor)
        {
            auto playtesting = this->config._level.at(folder).playtesting;
            details = format_with_level(playtesting.detail, this->level, this->game_level);
            s_state = format_with_level(playtesting.state, this->level, this->game_level);
            small_text = format_with_level(playtesting.smalltext, this->level, this->game_level);
            small_image = "creator_point";
        }
        else
        {
            auto saved = this->config._level.at(folder).saved;
            details = format_with_level(saved.detail, this->level, this->game_level);
            s_state = format_with_level(saved.state, this->level, this->game_level);
            small_text = format_with_level(saved.smalltext, this->level, this->game_level);
            small_image = gd_client::get_difficulty_name(this->level);
        }
        this->update_presence_w(details, large_text, small_text, s_state, small_image);
    }

    void loop::on_loop_editor()
    {
        std::string details, s_state, small_text, small_image;

        parse_game_level(this->game_level, this->level);
        auto folder = static_cast<size_t>(this->game_level->levelFolder);
        if (folder >= this->config._editor.size()) folder = 0;
        auto editor = this->config._editor.at(folder);
        details = format_with_level(editor.detail, level, this->game_level);
        s_state = format_with_level(editor.state, level, this->game_level);
        small_text = format_with_level(editor.smalltext, level, this->game_level);
        small_image = "creator_point";

        this->update_presence_w(details, large_text, small_text, s_state, small_image);
    }

    void loop::on_loop_menu()
    {
        std::string details, s_state, small_text, small_image;

        auto menu = this->config._menu;
        details = menu.detail;
        s_state = menu.state;
        small_text = menu.smalltext;
        small_image = "";

        this->update_presence_w(details, large_text, small_text, s_state, small_image);
    }

    void loop::on_loop()
    {
        discord::get()->run_callbacks();
        if (!this->update_presence) return;
        switch (this->state)
        {
        case player_state::level:
            this->on_loop_level();
            break;
        case player_state::editor:
            this->on_loop_editor();
            break;
        case player_state::menu:
            this->on_loop_menu();
            break;
        };
        this->update_presence = false;
    }
}