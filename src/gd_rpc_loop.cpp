#include "pch.h"
#include "gd_rpc_loop.h"
#include "gd_rpc_wrapper.h"
#include "gd_rpc_api.h"
#include "gd_rpc_settings.h"

namespace rpc
{
    static std::string get_text_from_key(std::string key) 
    {
        key.at(0) = std::toupper(key.at(0));
        int index = 1;
        std::for_each(key.begin() + 1, key.end(), [&index, &key](char& letter) 
            { 
                if (key.at(index - 1) == ' ') letter = std::toupper(letter); // then capitalises
                else if (letter == '_') letter = ' ';  
                index++; 
            });
        return key;
    }

    static std::string format_with_level(
        const std::string& string_format, 
        gd_level& level,
        ::gd::GJGameLevel* in_memory) 
    {
        try
        {
            return fmt::format(
                string_format,
                fmt::arg("id", level.level_id),
                fmt::arg("name", level.name),
                fmt::arg("best", in_memory->normalPercent),
                fmt::arg("diff", get_text_from_key(gd_client::get_difficulty_name(level))),
                fmt::arg("author", level.author),
                fmt::arg("stars", level.stars),
                fmt::arg("objects", in_memory->objectCount));
        }
        catch (const fmt::format_error& e)
        {
            GDRPC_LOG_ERROR("[GDRPC] failed to format level, {}", e.what());
            return string_format;
        }
    }

    void loop::update_discord_presence(
        std::string& details,
        std::string& large_text,
        std::string& small_text,
        std::string& state_text,
        std::string& small_image)
    {
        GDRPC_LOG_INFO("[GDRPC] setting presence -> details: {} | state: {} | small_text: {} | large_text: {} | timestamp_update: {}", 
            details.c_str(), 
            state_text.c_str(),
            small_text.c_str(),
            large_text.c_str(),
            update_timestamp);

        if (this->update_timestamp)
        {
            std::time(&this->current_timestamp);
            this->update_timestamp = false;
        }

        discord::get()->update(
            details.c_str(),
            large_text.c_str(),
            small_text.c_str(),
            state_text.c_str(),
            small_image.c_str(),
            this->current_timestamp);
    }

    void loop::disable_discord() 
    {
        if (!this->enabled) return;
        GDRPC_LOG_INFO("[GDRPC] rpc disabled!");
        this->enabled = false;
        discord::get()->shutdown();
    }

    void loop::enable_discord() 
    {
        if (this->enabled) return;
        GDRPC_LOG_INFO("[GDRPC] rpc enabled!");
        this->enabled = true;
        discord::get()->init(this->config._settings.application_id.c_str());
    }

    void loop::close()
    {
        GDRPC_LOG_INFO("[GDRPC] shutdown called!");
        discord::get()->shutdown();
    }

    DWORD WINAPI loop::main_thread(LPVOID lpParam) 
    {
        while (!GDRPC_ENABLED)
        {
            std::this_thread::sleep_for(std::chrono::milliseconds(250));
        }
        loop::get()->initialize_loop();
        while (true) 
        {
            try 
            {
                loop::get()->on_loop();
            }
            catch (const std::exception& e)
            {
                GDRPC_LOG_ERROR("[GDRPC] failed to do on_loop, {}", e.what());
            }
            catch (...) 
            {
                GDRPC_LOG_ERROR("[GDRPC] failed to do on_loop, unknown exception");
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        }
        return TRUE;
    }

    void loop::initialize_config() 
    {
        try
        {
            const auto path = get_app_data_path() / "Local" / "ToastedMarshmellow";
            if (!std::filesystem::exists(path)) std::filesystem::create_directories(path);
            const auto filename = path / "TM_GDRPC_Settings.toml";
            if (!std::ifstream(filename)) 
            {
                GDRPC_LOG_INFO("[GDRPC] initialized default config");
                std::ofstream config_file(filename);
                config_file 
                    << "# autogenerated config" << '\n'
                    << this->config.into_toml() 
                    << std::endl;
            }
            const toml::value config = toml::parse(filename.string());
            this->config.from_toml(config);
        }
        catch (const std::exception& e) 
        {
            GDRPC_LOG_ERROR("[GDRPC] failed to load config, {}", e.what());
        }
    }

    void loop::initialize_rank()
    {  
        const auto account_id = ::gd::GJAccountManager::sharedState()->m_nPlayerAccountID;
        GDRPC_LOG_INFO("[GDRPC] getting infomation for user {}", account_id);
        gd_user user;
        gd_client client(
            this->config._settings.base_url,
            this->config._settings.url_prefix);
        try
        {
            bool success = client.get_user_info(account_id, user);
            if (success) client.get_user_rank(user);
        }
        catch (const std::exception& e)
        {
            GDRPC_LOG_ERROR("[GDRPC] failed to get infomation, {}", e.what());
        }

        if (user.rank != -1)
        {
            this->large_text = fmt::format(
                this->config._user.ranked,
                fmt::arg("name", user.name),
                fmt::arg("rank", user.rank));
        }
        else
        {
            auto username = ::gd::GJAccountManager::sharedState()->getUsername();
            large_text = std::string(username);
        }
    }

    void loop::initialize_loop()
    {
        large_text = this->config._user._default;
        if (this->config._user.get_rank) this->initialize_rank();
        this->update_presence = true;
        this->update_timestamp = true;
    }

    void loop::on_loop_level()
    {
        std::string details, state_text, small_text, small_image;
        parse_game_level(this->game_level, this->level);
        const auto level_location = this->game_level->levelType;
        auto folder = static_cast<size_t>(this->game_level->levelFolder);
        if (folder >= this->config._level.size()) folder = 0;
        if (level_location == gd::GJLevelType::kGJLevelTypeEditor)
        {
            const auto playtesting = this->config._level.at(folder).playtesting;
            details = format_with_level(playtesting.detail, this->level, this->game_level);
            state_text = format_with_level(playtesting.state, this->level, this->game_level);
            small_text = format_with_level(playtesting.smalltext, this->level, this->game_level);
            small_image = "creator_point";
        }
        else
        {
            const auto saved = this->config._level.at(folder).saved;
            details = format_with_level(saved.detail, this->level, this->game_level);
            state_text = format_with_level(saved.state, this->level, this->game_level);
            small_text = format_with_level(saved.smalltext, this->level, this->game_level);
            small_image = gd_client::get_difficulty_name(this->level);
        }
        this->update_discord_presence(details, large_text, small_text, state_text, small_image);
    }

    void loop::on_loop_editor()
    {
        std::string details, state_text, small_text, small_image;
        parse_game_level(this->game_level, this->level);
        auto folder = static_cast<size_t>(this->game_level->levelFolder);
        if (folder >= this->config._editor.size()) folder = 0;
        auto editor = this->config._editor.at(folder);
        details = format_with_level(editor.detail, level, this->game_level);
        state_text = format_with_level(editor.state, level, this->game_level);
        small_text = format_with_level(editor.smalltext, level, this->game_level);
        small_image = "creator_point";
        this->update_discord_presence(details, large_text, small_text, state_text, small_image);
    }

    void loop::on_loop_menu()
    {
        std::string details, state_text, small_text, small_image;
        auto menu = this->config._menu;
        details = menu.detail;
        state_text = menu.state;
        small_text = menu.smalltext;
        small_image = std::string();
        this->update_discord_presence(details, large_text, small_text, state_text, small_image);
    }

    void loop::on_loop()
    {
        discord::get()->run_callbacks();
        if (!this->update_presence) return;
        switch (this->state)
        {
        case player_state::level:
            this->on_loop_level();
            break;
        case player_state::editor:
            this->on_loop_editor();
            break;
        case player_state::menu:
            this->on_loop_menu();
            break;
        };
        this->update_presence = false;
    }
}
